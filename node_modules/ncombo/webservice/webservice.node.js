var io = require('socket.io-client'),
	path = require('path'),
	EventEmitter = require('events').EventEmitter;
	
var sessionKey = null;

var WebServiceClient = function(host, port, secure) {
	var self = this;
	self._wsSocket = null;
	self._mainNamespace = null;
	self._namespaces = {};
	self._callTracker = {};
	self._callback = null;
	
	self._connectFailedMessage = 'Failed to connect to web service';
	
	self._timeout = 10000;
	
	self.host = host;
	self.port = port;
	self.secure = secure;
	
	self.MAX_ID = Math.pow(2, 53) - 2;
	self._curID = 1;
	self._genID = function() {
		self._curID++;
		self._curID = self._curID % self.MAX_ID;
		return 'r' + self._curID;
	}
	
	self.setTimeout = function(timeout) {
		self._timeout = timeout;
	}
	
	self.asClientURL = function(clientDesc) {
		return (clientDesc.secure ? 'https://' : 'http://') + clientDesc.host + ":" + clientDesc.port;
	}
	
	self._wsURL = self.asClientURL({host: host, port: port, secure: secure});
	
	self.getURL = function() {
		return self._wsURL;
	}
	
	self.disconnect = function(callback) {
		var cleanupHandler = function(err) {
			if(self._wsSocket) {
				self._wsSocket.removeListener('return', self._callReturn);
				self._wsSocket.removeListener('event', self._eventReceived);
			}
		}
		
		if(self._wsSocket && self._wsSocket.socket.connected) {
			self._destroy(function(err) {
				if(err) {
					callback && callback(err);
				} else {
					if(self._wsSocket) {
						self._callTracker = {};
						cleanupHandler();
						self._wsSocket.on('disconnect', function() {
							self._wsSocket.socket.connected = false;
							callback && callback(err);
							self.emit('disconnect');
						});
						self._wsSocket.disconnect();
					} else {
						self._callTracker = {};
						callback && callback(err);
						self.emit('disconnect');
					}
				}
			});
		} else {
			self._callTracker = {};
			cleanupHandler();
			callback && callback(err);
			self.emit('disconnect');
		}
	}
	
	self._listenForSocketEvents = function() {
		if(self._wsSocket.listeners('return').length < 1) {
			self._wsSocket.on('return', self._callReturn);
		}
		if(self._wsSocket.listeners('event').length < 1) {
			self._wsSocket.on('event', self._eventReceived);
		}
	}
	
	self._connect = function(callback) {
		var options = {'connect timeout': self._timeout};
		options.query = 'sskey=' + sessionKey;
		
		self._wsSocket = io.connect(self._wsURL, options);
		self._mainNamespace = self.ns('__main');
		self._namespaces = {'__main': self._mainNamespace};
		
		self._listenForSocketEvents();
		
		var connectHandler = function() {
			self._wsSocket.removeListener('connect', connectHandler);
			self._wsSocket.removeListener('connect_failed', connectFailHandler);
			self.emit('connection');
			callback && callback();
		}
		
		var connectFailHandler = function() {
			self._wsSocket.removeListener('connect', connectHandler);
			self._wsSocket.removeListener('connect_failed', connectFailHandler);
			self.emit('connect_failed');
			callback && callback(self._connectFailedMessage);
		}
		
		self._wsSocket.on('connect', connectHandler);
		self._wsSocket.on('connect_failed', connectFailHandler);
	}
	
	self.connect = function(callback) {
		var id = self._genID();
		
		if(self._wsSocket) {
			if(self._wsSocket.socket.connected) {
				callback && callback();
			} else if(self._wsSocket.socket.connecting) {
				self._wsSocket.on('connect', function() {
					callback && callback();
				});
				self._wsSocket.on('connect_failed', function() {
					callback && callback(self._connectFailedMessage);
				});
			} else {
				self._connect(callback);
			}
		} else {
			self._connect(callback);
		}
	}
	
	self._callReturn = function(data) {
		var id = data.id;
		if(self._callTracker[id]) {
			if(!data.noValue) {
				var finish = data.close ? true : false;
				if(self._callTracker[id]) {
					self._callTracker[id](data.error, data.value, finish);
				}
			}
			if(data.close) {
				delete self._callTracker[id];
			}
		}
	}
	
	self.trackRequest = function(id, callback) {
		self._callTracker[id] = callback;
	}
	
	self._eventReceived = function(event) {
		self.ns(event.ns)._triggerWatchers(event.event, event.data);
	}
	
	self.isConnected = function() {
		return self._wsSocket && self._wsSocket.socket.connected;
	}
	
	self.exec = function() {
		var serverInterface = arguments[0];
		var method = arguments[1];
		var id = self._genID();
		
		var request = {
			id: id,
			remote: true,
			host: host,
			port: port,
			secure: secure,
			sim: serverInterface,
			method: method
		};
		
		if(arguments[3]) {
			request.data = arguments[2];
			var callback = arguments[3];
			self._callTracker[id] = callback;
		} else if(arguments[2] !== undefined) {
			if(arguments[2] instanceof Function) {
				var callback = arguments[2];
				self._callTracker[id] = callback;
			} else {
				request.data = arguments[2];
			}
		}
		
		self.connect(function(err) {
			if(err) {
				if(self._callTracker[id]) {
					self._callTracker[id](err, null, true);
					delete self._callTracker[id];
				}
			} else {
				self._wsSocket.emit('localExec', request);
			}
		});
	}
	
	self.ns = function(namespace) {
		if(!self._namespaces[namespace]) {
			self._namespaces[namespace] = new NS(namespace, self._wsSocket, self);
		} else {
			self._namespaces[namespace].setSocket(self._wsSocket);
		}
		return self._namespaces[namespace];
	}
	
	self.watch = function() {
		self._mainNamespace.watch.apply(null, arguments);
	}
	
	self.unwatch = function() {
		self._mainNamespace.unwatch.apply(null, arguments);
	}
	
	self._destroy = function(ackCallback) {
		var i;
		var nsCount = 0;
		var nsSuccess = 0;
		var emittedFail = false;
		for(i in self._namespaces) {
			nsCount++;
		}
		
		if(nsCount) {
			for(i in self._namespaces) {
				self._namespaces[i]._unwatch(null, null, function(err) {
					if(err) {
						if(!emittedFail) {
							ackCallback && ackCallback('Failed to unwatch all events');
							emittedFail = true;
						}
					} else {
						if(++nsSuccess >= nsCount) {
							ackCallback && ackCallback();
						}
					}
				});
			}
		} else {
			ackCallback && ackCallback();
		}
	}
	
	self.destroy = function(ackCallback) {
		self.connect(function(err) {
			if(err) {
				ackCallback && ackCallback(err);
			} else {
				self._destroy(ackCallback);
			}
		});
	}
	
	self.isWatching = function() {
		self._mainNamespace.isWatching.apply(null, arguments);
	}
}

WebServiceClient.prototype.__proto__ = EventEmitter.prototype;

var NS = function(namespace, wsSocket, wsClient) {
	var self = this;
	self._namespace = namespace;
	self._wsSocket = wsSocket;
	self._wsClient = wsClient;
	self._serverWatchMap = {};
	
	self.MAX_ID = Math.pow(2, 53) - 2;
	self._curID = 1;
	self._genID = function() {
		self._curID++;
		self._curID = self._curID % self.MAX_ID;
		return 'rn' + self._curID;
	}
	
	self.setSocket = function(socket) {
		self._wsSocket = socket;
	}
	
	self.watch = function(event, handler, ackCallback) {
		self._wsClient.connect(function(err) {
			if(err) {
				ackCallback && ackCallback(err);
			} else {
				if(!self._serverWatchMap.hasOwnProperty(event)) {
					self._serverWatchMap[event] = [];
				}
				self._serverWatchMap[event].push(handler);
				
				var ackHandler = function(err, alreadyWatching) {
					if(err || alreadyWatching) {
						var newWatchMap = [];
						var i;
						for(i in self._serverWatchMap[event]) {
							if(self._serverWatchMap[event][i] != handler) {
								newWatchMap.push(self._serverWatchMap[event][i]);
							}
						}
						self._serverWatchMap[event] = newWatchMap;
					}
					ackCallback && ackCallback(err);
				}
				
				if(self._serverWatchMap[event].length < 2) {
					var id = self._genID();
					var request = {
						id: id,
						remote: true,
						host: self._wsClient.host,
						port: self._wsClient.port,
						secure: self._wsClient.secure,
						ns: self._namespace,
						event: event
					};
					
					self._wsClient.trackRequest(id, ackHandler);
					self._wsSocket.emit('watchLocal', request);
				} else {
					ackCallback && ackCallback();
				}
			}
		});
	}
	
	self._unwatch = function(event, handler, ackCallback) {
		var i, j;
		var id = self._genID();
		var unwatchRequest = {
			id: id,
			remote: true,
			host: self._wsClient.host,
			port: self._wsClient.port,
			secure: self._wsClient.secure,
			ns: self._namespace,
			event: event
		};
		
		if(!event) {
			self._serverWatchMap = {};
			self._wsClient.trackRequest(id, ackCallback);
			self._wsSocket.emit('unwatchLocal', unwatchRequest);
		} else if(!handler) {
			if(self._serverWatchMap[event]) {				
				delete self._serverWatchMap[event];
				self._wsClient.trackRequest(id, ackCallback);
				self._wsSocket.emit('unwatchLocal', unwatchRequest);
			} else {
				ackCallback && ackCallback();
			}
		} else {
			if(self._serverWatchMap[event]) {
				var len = self._serverWatchMap[event].length;
				var newEventList = [];
				for(i=0; i<len; i++) {
					if(self._serverWatchMap[event][i] != handler) {
						newEventList.push(self._serverWatchMap[event][i]);
					}
				}
				
				self._serverWatchMap[event] = newEventList;
				
				if(newEventList < 1) {
					self._wsClient.trackRequest(id, ackCallback);
					self._wsSocket.emit('unwatchLocal', unwatchRequest);
				} else {
					ackCallback && ackCallback();
				}
			} else {
				ackCallback && ackCallback();
			}
		}
	}
	
	self.unwatch = function(event, handler, ackCallback) {
		self._wsClient.connect(function(err) {
			if(err) {
				ackCallback && ackCallback(err);
			} else {
				self._unwatch(event, handler, ackCallback);
			}
		});
	}
	
	self._getWatcher = function(event, handler) {
		if(self._serverWatchMap[event]) {
			var watchers = self._serverWatchMap[event];
			var len = watchers.length;
			var i;
			for(i=0; i<len; i++) {
				if(watchers[i] == handler) {
					return watchers[i];
				}
			}
		}
		return null;
	}
	
	self.isWatching = function(event, handler) {
		if(handler) {
			return self._getWatcher(event, handler) ? true : false;
		} else {
			return self._serverWatchMap.hasOwnProperty(event);
		}
	}
	
	self._triggerWatchers = function(event, data) {
		if(self._serverWatchMap && self._serverWatchMap[event]) {
			var watchers = self._serverWatchMap[event];
			var len = watchers.length;
			var i;
			for(i=0; i<len; i++) {
				watchers[i].call(null, data);
			}
		}
	}
}

var WebService = function() {
	var self = this;
	self._webServiceMap = {};
	self._watchMap = {};
	
	self._releaseMode = false;
	self._timeout = 10000;
	
	self.init = function(sessionID) {
		sessionKey = sessionID;
	}
	
	self.setReleaseMode = function(bool) {
		self._releaseMode = bool;
	}
	
	self.setTimeout = function(timeout) {
		self._timeout = timeout;
	}
	
	self.isEmpty = function(object) {
		var i;
		var empty = true;
		for(i in object) {
			empty = false;
			break;
		}
		return empty;
	}
	
	self.exec = function(ioReq, ioRes) {
		var client = self.getClient(ioReq.host, ioReq.port, ioReq.secure);
		var serverInterface = ioReq.sim;
		var method = ioReq.method;
		var data = ioReq.data;
		
		var callback = function(err, data, finish) {
			if(err) {
				ioRes.error(err, finish);
				console.log(err);
			} else {
				if(finish) {
					ioRes.end(data);
				} else {
					ioRes.send(data);
				}
			}
		}
		
		client.connect(function(err) {
			if(err) {
				callback(err, null, true);
			} else {
				client.exec(serverInterface, method, data, callback);
			}
		});
	}
	
	self.watch = function(ioReq, ioRes) {
		var id = ioReq.session.id;
		var client = self.getClient(ioReq.host, ioReq.port, ioReq.secure);
		
		var eventData = {
			remote: true,
			host: ioReq.host,
			port: ioReq.port,
			secure: ioReq.secure,
			ns: ioReq.ns,
			event: ioReq.event
		};
		
		var handler = function(data) {
			eventData.data = data;
			ioReq.session.ns(ioReq.ns).emitRaw(eventData);
		}
		
		if(client.ns(ioReq.ns).isWatching(ioReq.event)) {
			ioRes.end();
		} else {
			client.ns(ioReq.ns).watch(ioReq.event, handler, function(err) {
				if(err) {
					ioRes.error(err, true);
				} else {
					if(!self._watchMap.hasOwnProperty(id)) {
						self._watchMap[id] = {};
					}
					var curClientURL = client.getURL();
					self._watchMap[id][curClientURL] = client;					
					ioRes.end();
				}
			});
		}
	}
	
	self.unwatch = function(ioReq, ioRes) {
		var socket = ioReq.socket;
		var id = ioReq.session.id;
		
		var client = self.getClient(ioReq.host, ioReq.port, ioReq.secure);
		client.ns(ioReq.ns).unwatch(ioReq.event, null, function(err) {
			if(err) {
				ioRes.error(err, true);
			} else {
				ioRes.end();
			}
		});		
	}
	
	self.destroy = function(session, ackCallback) {
		var id = session.id;
		var curClients = self._watchMap[id];
		delete self._watchMap[id];
		var i;
		var clientCount = 0;
		var numDestroyed = 0;
		for(i in curClients) {
			clientCount++;
		}
		for(i in curClients) {
			curClients[i].disconnect(function() {
				if(++numDestroyed >= clientCount) {
					ackCallback && ackCallback.apply(null, arguments);
				}
			});
		}
	}
	
	self.getClient = function(host, port, secure) {
		var url = (secure ? 'https://' : 'http://') + host + ":" + port;
		if(!self._webServiceMap.hasOwnProperty(url)) {
			self._webServiceMap[url] = new WebServiceClient(host, port, secure);
			self._webServiceMap[url].setTimeout(self._timeout);
		}
		
		return self._webServiceMap[url];
	}
}

WebService.prototype.__proto__ = EventEmitter.prototype;

module.exports = new WebService();
