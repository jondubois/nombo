var http = require('http');
var httpProxy = require('http-proxy');
var url = require('url');

var LoadBalancer = function (options) {
	var self = this;

	this.protocol = options.protocol || 'http';
	this.protocolOptions = options.protocolOptions;
	this.sourcePort = options.sourcePort;
	this.destPorts = options.destPorts;
	this.checkWorkersInterval = options.checkWorkersInterval || 10000;
	
	this._destRegex = /^([^_]*)_([^_]*)_/;
	this._sidRegex = /([^A-Za-z0-9]|^)s?sid=([^;]*)/;
	
	var proxyHTTP = function (req, res, proxy) {
		var dest = self._getDest(req);
		proxy.proxyRequest(req, res, dest);
	};

	var proxyWebSocket = function (req, socket, head) {
		var dest = self._getDest(req);
		self.server.proxy.proxyWebSocketRequest(req, socket, head, dest);
	};
	
	httpProxy.setMaxSockets(Infinity);
	
	this.server = httpProxy.createServer(proxyHTTP);
	this.server.on('upgrade', proxyWebSocket);
	
	this.server.listen(this.sourcePort);
	
	this.workerStatuses = {};
	this.leastBusyPort = this._randomPort();
	
	this._updateStatus();
	setInterval(this._updateStatus.bind(this), this.checkWorkersInterval);
};

LoadBalancer.prototype.setDestPorts = function (ports) {
	this.destPorts = ports;
};

LoadBalancer.prototype._randomPort = function() {
	var rand = Math.floor(Math.random() * this.destPorts.length);
	return this.destPorts[rand];
};

LoadBalancer.prototype._updateStatus = function () {
	var self = this;
	
	self._getWorkerClientCounts(function (counts) {
		var minClientCount = Infinity;
		var leastBusyPort;
		var clientCount;
		
		for (var i in counts) {
			clientCount = counts[i].clientCount;
			if (clientCount < minClientCount) {
				minClientCount = clientCount;
				leastBusyPort = i;
			}
		}
		if (minClientCount == Infinity) {
			leastBusyPort = self._randomPort();
		}
		
		self.workerStatuses = counts;
		self.leastBusyPort = leastBusyPort;
		console.log(self.leastBusyPort);
	});
};

LoadBalancer.prototype._getWorkerClientCounts = function (callback) {
	var clientCounts = {};
	var expectedCount = this.destPorts.length;
	var responseCount = 0;
	var port;
	
	for (var i in this.destPorts) {
		(function (port) {
			var req = http.get({
				hostname: 'localhost',
				port: port,
				path: '/~statusrequest'
			}, function (res) {
				var buffer = '';
				res.on('error', function () {
					buffer = '';
				});
				res.on('data', function (chunk) {
					buffer += chunk;
				});
				res.on('end', function () {
					if (buffer) {
						clientCounts[port] = JSON.parse(buffer);
					} else {
						clientCounts[port] = {clientCount: Infinity};
					}
					if (++responseCount >= expectedCount) {
						callback(clientCounts);
					}
				});
			});
			req.on('error', function () {
				console.log('    Failed to get worker status on port ' + port);
			});
		})(this.destPorts[i]);
	}
};

LoadBalancer.prototype._parseDest = function (req) {
	var query = url.parse(req.url).query;
	
	if (!query) {
		return null;
	}
	
	var matches = query.match(this._sidRegex);
	
	if (!matches) {
		return null;
	}
	
	var routString = matches[2];
	var result = routString.match(this._destRegex);
	
	if (!result) {
		return null;
	}
	
	var dest = {
		host: result[1] || 'localhost',
		port: parseInt(result[2]) || this.leastBusyPort
	};
	
	return dest;
};

LoadBalancer.prototype._getDest = function(req) {
	var dest = this._parseDest(req);
	
	if (!dest) {
		dest = {
			host: 'localhost',
			port: this.leastBusyPort
		};
	}
	return dest;
};

module.exports = LoadBalancer;