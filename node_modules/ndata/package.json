{
  "name": "ndata",
  "description": "nData key-value store",
  "version": "0.9.21",
  "author": {
    "name": "JF Gros-Dubois",
    "email": "flashthink@gmail.com"
  },
  "contributors": [
    {
      "name": "JF Gros-Dubois",
      "email": "flashthink@gmail.com"
    }
  ],
  "dependencies": {
    "fleximap": "0.9.0",
    "ncom": "0.9.0"
  },
  "devDependencies": {},
  "keywords": [
    "ndata",
    "ncombo",
    "key value store",
    "key value server",
    "session"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/topcloud/ndata.git"
  },
  "main": "index",
  "engines": {
    "node": ">= 0.8.0"
  },
  "optionalDependencies": {},
  "scripts": {
    "start": "node server.js"
  },
  "readme": "nData\n======\n\nnData is a lightweight key-value store server and client pair.\nIt is written entirely in node.js for maximum portability.\n\n## Installation\n\n```bash\nnpm install ndata\n```\n\n## Overview\n\nTo use it call:\nvar ndata = require('ndata');\n\nFirstly, launch a new nData server. If you're using the node cluster module, you might want to launch the nData server once \nfrom the master process and then interact with it using nData clients.\n\nTo launch the server, use:\nvar dataServer = ndata.createServer(port, secretKey)\n\nThe secretKey argument is optional; you should use it if you want to restrict access to the server.\nIf you're running a node cluster, you may want to use a random key and distribute it to all the workers so that only\nyour application can interact with the nData server.\n\nOnce the server is setup, you should create clients to interact with it. **Make sure that the server is running before creating clients; listen for the 'ready' event on the server.**\nTo create a client use:\nvar dataClient = ndata.createClient(port, secretKey);\n\nThe port and secret key must match those supplied to the createServer function.\n\nThe client exposes the following methods:\n(Please see the section on keys (below) to see how you can use keys in nData.\nAlso, note that the callback argument in all of the following cases is optional.)\n\n- run(code, callback) - Run a JavaScript function declaration (code) as a query on the nData server - This function declaration accepts the DataMap as a parameter.\nThis is the most important data function in nData, all the other data functions are utility functions to make things quicker. Using run() offers the most flexibility.\nWhen using run(), make sure that you escape user input using the input() function.\nThe callback is in form: callback(err, data) Example:\n\n```js\nclient.run('function(DataMap) { DataMap.set(\"main.message\", \"This is an important message\"); return DataMap.get(\"main\"); }', function(err, data) {\n\tconsole.log(data); // outputs {message: \"This is an important message\"}\n});\n```\n\n- input(value) - Escapes user input to make it safe for use within run(). The value parameter can be any JSON-compatible object.\n\n- set(key, value, callback) - Set a key-value pair, when the operation has been completed, callback will be executed.\nThe callback is in form: callback(err)\n\n- add(key, value, callback) - Append a value to the given key; the object at key will be treated as an array. If a value already exists at that key and is not an array,\nthis existing value will be placed inside an empty array and the specified value argument will be appended to that array.\nThe callback is in form: callback(err)\n\n- concat(key, value, callback) - Concatenate the array or object at key with the specified array or object (value).\nThe callback is in form: callback(err)\n\n- remove(key,[getValue,] callback) - Remove the value at key. If value is an array, it will remove the entire array.\nThe optional getValue is a boolean which indicates whether or not to get the removed value in the callback.\nThe callback is in form: callback(err, value)\n\n- removeRange(key, fromIndex,[ toIndex, getValue,] callback) - Remove a range of values at key between fromIndex and toIndex.\nThis function assumes that the value at key is an object or array. The optional getValue argument specified whether or not to return the removed section as an argument to the callback.\nThe callback is in form: callback(err, value)\n\n- removeAll(callback) - Clear nData completely.\nThe callback is in form: callback(err)\n\n- pop(key,[getValue,] callback) - Remove the last numerically-indexed entry at key; callback is in the form: callback(err, value).\nThe optional getValue is a boolean which indicates whether or not to get the removed value in the callback.\nThe callback is in form: callback(err, value)\n\n- get(key, callback) - Get the value at key; callback is in form: callback(err, value)\n\n- getRange(key, fromIndex,[ toIndex,] callback) - This function assumes that the value at key is an Array or Object;\ncapture all values starting at fromIndex and finishing at toIndex (but not including toIndex).\nIf toIndex is not specified, all values from fromIndex until the end of the Array/Object will be included).\nThe callback is in form: callback(err, value)\n\n- getAll(callback) - Get all the values in nData; callback is in form: callback(err, value)\n\n- count(key, callback) - Count the number of elements at key; callback is in form: callback(err, value)\n\n- watch(event, handler, ackCallback) - Watch for an event on nData, handler is a callback in the form handler(value) where value is a value sent with the event.\nNote that you can watch the same event multiple times (even using the same handler).\n\n- watchOnce(event, handler, ackCallback) - As above except that it will only trigger a single handler (from the last call to watchOnce).\n\n- unwatch(event, handler, ackCallback) - Unwatch the specified event. If handler is not specified, it will remove handlers associated with the specified event.\nIf event is not specified, it will remove all nData events.\n\n- broadcast(event, value, callback) - Broadcast an event with the specified associated value.\n\n## Keys\n\nnData is very flexible with how you can use keys. It lets you set key chains of any dimension without having to manually create each link in the chain.\nFor example, when you start, nData will be empty, but this code is perfectly valid:\ndataClient.set('this.is.a.deep.key', 'Hello world');\n\nIn this case, nData will create the necessary key chain and set the bottom-level 'key' to 'Hello World'.\nIf you were to call:\ndataClient.get('this.is.a', function(value) {\n\tconsole.log(value);\n});\n\nThe above would output: {deep:{key:'Hello world'}}\n\nnCombo generally doesn't restrict you from doing anything you want. It is perfectly OK to call this:\n\ndataClient.add('this.is.a', 'foo');\n\nIn this case, the key chain 'this.is.a' would evaluate to:\n{0:'foo',deep:{key:'Hello world'}}\n\nIn this case, nData will add the value at the next numeric index in the specified key path (which in this case is 0).\nYou can access numerically-indexed values like this:\ndataClient.get('this.is.a.0', function(value) {\n\tconsole.log(value);\n});\n\nThe output here will be 'foo'.\nYou can also add entire JSON-compatible objects as value. Objects with circular references are also valid.\n\n\n## Special Macros\n\nSpecial macros serve to extend the capabilities of nData - They can be applied within both the key and the value arguments supplied to any nData method (basically any string supplied to nData).\n\nIn nData, the dot (.) character is special - By default it serves to delimit different depths in the key chain.\nThere may be cases where you want a dot character to be interpreted literally - In this case, you should use the #() macro.\nAny text placed within a #() macro will be treated as a literal - Dots and other special symbols (including other macros) will be escaped.\n\nFor example, if you have:\n\n```js\ndataClient.set('#(this.is.a.shallow.key)', 'Hello world');\n```\n\nIf you tried running this:\n\n```js\ndataClient.get('this.is.a', function(value) {\n\tconsole.log(value);\n});\n```\n\nValue would be undefined.\nTo actually retrieve the value, you would need to do it like this:\n\n```js\ndataClient.get('#(this.is.a.shallow.key)', function(value) {\n\tconsole.log(value);\n});\n```\n\nYou need to be consistent in how you escape the chain.\n\nTo evaluate expressions, you may use the %() macro.\n\nExample:\n\n```js\ndataClient.set('value', 'Number: %(8 + 2)'); // This would store the string 'Number: 10'\n```\n\nSometimes you may want to substitute the value of an object that is already stored within nData, in this case, use the $() macro.\n\nExample (also using evaluation macro):\n\n```js\ndataClient.set('valueA', 1, function(err) {\n\tdataClient.set('valueB', '%($(valueA) + 1)'); // This would set valueB to the number 2\n});\n```",
  "readmeFilename": "README.md",
  "_id": "ndata@0.9.20",
  "_from": "ndata@>= 0.9.20"
}
