var engine = require('engine.io');
var Server = engine.Server;
var ClusterSocket = require('./clustersocket');
var transports = engine.transports;
var EventEmitter = require('events').EventEmitter;
var base64id = require('base64id');

var ClusterServer = function(options) {
	var opts = {};
	for (var i in options) {
		opts[i] = options[i];
	}

	opts.pingTimeout = opts.pingTimeout * 1000;
	opts.pingInterval = opts.pingInterval * 1000;
	opts.upgradeTimeout = opts.upgradeTimeout * 1000;
	
	Server.call(this, opts);
	
	this._ioClusterClient = options.ioClusterClient;
	this._sessionIdRegex = /(__.*\/nc_ssid=)([^;]*)/;
	this._hostRegex = /^[^:]*/;
};

ClusterServer.prototype = Object.create(Server.prototype);

ClusterServer.prototype._parseSessionId = function (cookieString) {
	if(typeof cookieString == 'string') {
		var result = cookieString.match(this._sessionIdRegex);
		if(result) {
			return result[2];
		}
	}
	return null;
};

ClusterServer.prototype.on = function (event, listener) {
	if (event == 'ready') {
		this._ioClusterClient.on(event, listener);
	} else {
		Server.prototype.on.apply(this, arguments);
	}
};

ClusterServer.prototype.removeListener = function (event, listener) {
	if (event == 'ready') {
		this._ioClusterClient.removeListener(event, listener);
	} else {
		Server.prototype.removeListener.apply(this, arguments);
	}
};

ClusterServer.prototype.sendErrorMessage = function (res, code) {
	res.writeHead(400, {'Content-Type': 'application/json'});
	res.end(JSON.stringify({
		code: code,
		message: Server.errorMessages[code]
	}));
};

ClusterServer.prototype.generateId = function (req) {
	var host = req.headers.host.match(this._hostRegex);
	if (host) {
		host = host[0];
	} else {
		host = '';
	}
	var port = req.connection.address().port;
	return host + '_' + port + '_' + base64id.generateId();
};

ClusterServer.prototype.handshake = function (transport, req) {
	var self = this;
	var id = this.generateId(req);
	try {
		var transport = new transports[transport](req);
	} catch (e) {
		this.sendErrorMessage(req.res, Server.errors.BAD_REQUEST);
		return;
	}
	
	var socket = new ClusterSocket(id, this, transport);

	if (false !== this.cookie) {
		transport.on('headers', function (headers) {
			headers['Set-Cookie'] = self.cookie + '=' + id;
		});
	}

	transport.onRequest(req);

	this.clients[id] = socket;
	this.clientsCount++;
	
	var headers = req.headers || {};
	
	if (req.connection) {
		socket.address = req.connection.remoteAddress;
	}
	var ssid = this._parseSessionId(headers.cookie);
	socket.ssid = ssid || socket.id;
	socket.session = this._ioClusterClient.session(socket.ssid);
	socket.global = this._ioClusterClient.global();
	
	this._ioClusterClient.bind(socket, function (err) {
		if (err) {
			self.emit('error', 'Failed to bind socket to io cluster');
		} else {
			self.emit('connection', socket);
		}
	});
	
	socket.once('close', function () {
		self._ioClusterClient.unbind(socket, function(err) {
			if (err) {
				self.emit('error', 'Failed to unbind socket from io cluster');
			} else {
				delete self.clients[id];
				self.clientsCount--;
				self.emit('close', 'Socket was disconnected');
			}
		});
	});
};

module.exports = ClusterServer;