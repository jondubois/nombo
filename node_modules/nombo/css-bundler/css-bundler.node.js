var fs = require('fs');
var path = require('path');
var pathManager = require('nombo/pathmanager');
var EventEmitter = require('events').EventEmitter;
var watchr = require('watchr');
var cleanCSS = require('clean-css');

module.exports = function (options) {
	var self = new EventEmitter();
	
	var windowsSepRegex = /\\/g;
	var styleExtRegex = /[.](css|less)$/;
	var importRegex = /@import +(url *[(])?["']?([^"']+)["']?[)]?;?(\r?\n)?/g;
	var urlRegex = /([^A-Za-z0-9]|^)url[(][ ]*["']?([^"')]*)["']?[ ]*[)]/g;
	var subs = {};
	var files = options.files;
	var watch = options.watch;
	var watchDirs = options.watchDirs;
	var assetsMap = {};
	
	if (watch) {
		var emitBundle = function () {
			self.emit('update');
		}
		watchr.watch({
			paths: watchDirs,
			listener: emitBundle,
			catchupDelay: 1000
		});
	}
	
	self.removeComments = function (css) {
		css = css.split('');
		var num = css.length;
		var capturing = true;
		var buf = '';
		
		var i;
		for (i=0; i<num; i++) {
			if (css[i] == '/' && css[i+1] == '*') {
				capturing = false;
			} else if (css[i] == '*' && css[i+1] == '/') {
				capturing = true;
				i += 2;
			}
			if (i >= num) {
				break;
			}
			if (capturing) {
				buf += css[i];
			}
		}
		return buf;
	}
	
	self.minify = function (css) {
		return cleanCSS.process(css);
	}
	
	self._toUnixSep = function (filePath) {
		return filePath.replace(windowsSepRegex, '/');
	}
	
	self._subImportedPaths = function (filePath, content, urlTransformFunction, rootDir, subFunction) {
		var pathAdjust, newURL;
		
		content = content.replace(urlRegex, function (match, first, second) {
			pathAdjust = path.relative(rootDir, path.dirname(filePath));
			if (pathAdjust) {
				pathAdjust += '/';
			}
			newURL = self._toUnixSep(path.normalize(pathAdjust + second));
			
			if (!styleExtRegex.test(newURL)) {
				rootDir = pathManager.toUnixSep(rootDir);
				newURL = pathManager.pathToURL(rootDir + '/' + newURL);
				newURL = pathManager.toUnixSep(path.normalize(newURL));
				
				if (urlTransformFunction) {
					newURL = urlTransformFunction(newURL);
				}
			}
			return first + 'url("' + newURL + '")';
		});
		
		content = content.replace(importRegex, function (match, first, second) {
			if (subs.hasOwnProperty(second)) {
				return '';
			} else {
				subs[second] = true;
				return subFunction(second, urlTransformFunction, rootDir);
			}
		});
		
		return content;
	}
	
	self._inlineImports = function (filePath, urlTransformFunction, rootDir) {
		if (rootDir) {
			filePath = path.normalize(rootDir + '/' + filePath);
		} else {
			subs = {};
			rootDir = path.normalize(path.dirname(filePath));
		}
		
		var content;
		if (fs.existsSync(filePath)) {
			content = self.removeComments(fs.readFileSync(filePath, 'utf8'));
		} else {
			content = '';
		}
		
		return self._subImportedPaths(filePath, content, urlTransformFunction, rootDir, self._inlineImports);
	}
	
	self.getAssetURLs = function () {
		var assets = [];
		var i;
		for (i in assetsMap) {
			assets.push(i);
		}
		return assets;
	}
	
	self.getAssetSizeMap = function () {
		var sizes = {};
		var assets = self.getAssetURLs();
		var curPath, stats;
		for (i in assets) {
			curPath = pathManager.urlToPath(assets[i]);
			if (fs.existsSync(curPath)) {
				stats = fs.statSync(curPath);
				sizes[assets[i]] = stats.size;
			}
		}
		return sizes;
	}
	
	self.bundle = function (urlTransformFunction) {
		if (!(files instanceof Array)) {
			files = [files];
		}
		var content = [];
		
		var urlCallback = function (url) {
			if (urlTransformFunction) {
				url = urlTransformFunction(url);
			}
			url = path.normalize(url);
			assetsMap[url] = true;
			return url;
		}
		
		var i, file;
		for (i in files) {
			file = files[i];
			content.push(self._inlineImports(file, urlCallback));
		}
		
		subs = {};
		return content.join('\n');
	}
	
	return self;
};