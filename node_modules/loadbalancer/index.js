var http = require('http');
var httpProxy = require('http-proxy');
var url = require('url');
var crypto = require('crypto');
var ComSocket = require('ncom').ComSocket;

var LoadBalancer = function (options) {
	var self = this;

	this.protocol = options.protocol || 'http';
	this.protocolOptions = options.protocolOptions;
	this.sourcePort = options.sourcePort;
	
	this.destPorts = {};
	var i;
	
	for (i in options.workers) {
		this.destPorts[options.workers[i].port] = 1;
	}
	this.workers = options.workers;
	
	this.dataKey = options.dataKey;
	this.checkWorkersInterval = 5000;

	this._destRegex = /^([^_]*)_([^_]*)_/;
	this._sidRegex = /([^A-Za-z0-9]|^)s?sid=([^;]*)/;

	var proxyHTTP = function (req, res, proxy) {
		var dest = self._parseDest(req);
		if (dest) {
			if (self.destPorts[dest.port] == null) {
				dest.port = self._randomPort();
			}
		} else {
			dest = {
				host: 'localhost',
				port: self._randomPort()
			};
		}
		proxy.proxyRequest(req, res, dest);
	};

	var proxyWebSocket = function (req, socket, head) {
		var dest = self._parseDest(req);
		if (dest) {
			if (self.destPorts[dest.port] == null) {
				dest.port = self._randomPort();
			}
		} else {
			dest = {
				host: 'localhost',
				port: self.leastBusyPort
			};
		}
		self.server.proxy.proxyWebSocketRequest(req, socket, head, dest);
	};
	
	httpProxy.setMaxSockets(Infinity);
	
	this.server = httpProxy.createServer(proxyHTTP);
	this.server.listen(this.sourcePort);
	
	this.workerStatusSockets = {};
	this.workerStatuses = {};
	this.leastBusyPort = this._randomPort();
	
	var socket, port;
	for (i in this.workers) {
		port = this.workers[i].port;
		socket = new ComSocket();
		this.workerStatusSockets[port] = socket;
		socket.connect(this.workers[i].statusPort, 'localhost');
		
		(function (port) {
			socket.on('message', function (message) {
				self.workerStatuses[port] = message;
			});
			
			socket.on('close', function () {
				self.workerStatuses[port] = null;
			});
		})(port);
	}
	
	setInterval(this._updateStatus.bind(this), this.checkWorkersInterval);
};

LoadBalancer.prototype._randomPort = function() {
	var rand = Math.floor(Math.random() * this.workers.length);
	return this.workers[rand].port;
};

LoadBalancer.prototype._updateStatus = function () {
	var minClientCount = Infinity;
	var leastBusyPort;
	var clientCount;
	
	for (var i in this.workerStatuses) {
		if (this.workerStatuses[i]) {
			clientCount = this.workerStatuses[i].clientCount;
		} else {
			clientCount = Infinity;
		}
		if (clientCount < minClientCount) {
			minClientCount = clientCount;
			leastBusyPort = parseInt(i);
		}
	}
	if (minClientCount == Infinity) {
		leastBusyPort = this._randomPort();
	}
	this.leastBusyPort = leastBusyPort;
};

LoadBalancer.prototype._parseDest = function (req) {
	var urlData = url.parse(req.url);
	var query = urlData.query || '';
	var cookie = '';
	
	if (req.headers && req.headers.cookie) {
		cookie = req.headers.cookie;
	}
	
	if (!query && !cookie) {
		return null;
	}
	
	var matches = query.match(this._sidRegex) || cookie.match(this._sidRegex);
	
	if (!matches) {
		return null;
	}
	
	var routString = matches[2];
	var result = routString.match(this._destRegex);
	
	if (!result) {
		return null;
	}
	
	var dest = {
		host: 'localhost',
		port: parseInt(result[2]) || this.leastBusyPort
	};
	
	return dest;
};

module.exports = LoadBalancer;