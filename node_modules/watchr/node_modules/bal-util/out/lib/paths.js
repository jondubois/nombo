// Generated by CoffeeScript 1.6.2
(function() {
  var balUtilFlow, balUtilPaths, balUtilTypes, fsUtil, pathUtil, _ref, _ref1, _ref2, _ref3, _ref4, _ref5,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  fsUtil = require('fs');

  pathUtil = require('path');

  balUtilFlow = require('./flow');

  balUtilTypes = require('./types');

  if ((_ref = global.numberOfOpenFiles) == null) {
    global.numberOfOpenFiles = 0;
  }

  if ((_ref1 = global.maxNumberOfOpenFiles) == null) {
    global.maxNumberOfOpenFiles = (_ref2 = process.env.NODE_MAX_OPEN_FILES) != null ? _ref2 : 100;
  }

  if ((_ref3 = global.waitingToOpenFileDelay) == null) {
    global.waitingToOpenFileDelay = 100;
  }

  balUtilPaths = {
    ignoreCommonPatterns: (_ref4 = process.env.NODE_IGNORE_COMMON_PATTERNS) != null ? _ref4 : /^((~|\.\#).*|.*(\.swp)|\.(svn|git|hg|DS_Store)|node_modules|CVS|thumbs\.db|desktop\.ini)$/i,
    ignoreCustomPatterns: (_ref5 = process.env.NODE_IGNORE_CUSTOM_PATTERNS) != null ? _ref5 : null,
    textExtensions: ['c', 'coffee', 'coffeekup', 'cson', 'css', 'eco', 'haml', 'hbs', 'htaccess', 'htm', 'html', 'jade', 'js', 'json', 'less', 'md', 'php', 'phtml', 'py', 'rb', 'rtf', 'sass', 'scss', 'styl', 'stylus', 'text', 'txt', 'xml', 'yaml'].concat((process.env.TEXT_EXTENSIONS || '').split(/[\s,]+/)),
    binaryExtensions: ['dds', 'eot', 'gif', 'ico', 'jar', 'jpeg', 'jpg', 'pdf', 'png', 'swf', 'tga', 'ttf', 'zip'].concat((process.env.BINARY_EXTENSIONS || '').split(/[\s,]+/)),
    openFile: function(next) {
      if (global.numberOfOpenFiles < 0) {
        throw new Error("balUtilPaths.openFile: the numberOfOpenFiles is [" + global.numberOfOpenFiles + "] which should be impossible...");
      }
      if (global.numberOfOpenFiles >= global.maxNumberOfOpenFiles) {
        setTimeout(function() {
          return balUtilPaths.openFile(next);
        }, global.waitingToOpenFileDelay);
      } else {
        ++global.numberOfOpenFiles;
        next();
      }
      return this;
    },
    closeFile: function(next) {
      --global.numberOfOpenFiles;
      if (typeof next === "function") {
        next();
      }
      return this;
    },
    readFile: function(path, encoding, next) {
      if (next == null) {
        next = encoding;
        encoding = null;
      }
      balUtilPaths.openFile(function() {
        return fsUtil.readFile(path, encoding, function(err, data) {
          balUtilPaths.closeFile();
          return next(err, data);
        });
      });
      return this;
    },
    writeFile: function(path, data, encoding, next) {
      if (next == null) {
        next = encoding;
        encoding = null;
      }
      balUtilPaths.ensurePath(pathUtil.dirname(path), function(err) {
        if (err) {
          return next(err);
        }
        return balUtilPaths.openFile(function() {
          return fsUtil.writeFile(path, data, encoding, function(err) {
            balUtilPaths.closeFile();
            return next(err);
          });
        });
      });
      return this;
    },
    mkdir: function(path, mode, next) {
      if (next == null) {
        next = mode;
        mode = null;
      }
      balUtilPaths.openFile(function() {
        return fsUtil.mkdir(path, mode, function(err) {
          balUtilPaths.closeFile();
          return next(err);
        });
      });
      return this;
    },
    stat: function(path, next) {
      balUtilPaths.openFile(function() {
        return fsUtil.stat(path, function(err, stat) {
          balUtilPaths.closeFile();
          return next(err, stat);
        });
      });
      return this;
    },
    readdir: function(path, next) {
      balUtilPaths.openFile(function() {
        return fsUtil.readdir(path, function(err, files) {
          balUtilPaths.closeFile();
          return next(err, files);
        });
      });
      return this;
    },
    unlink: function(path, next) {
      balUtilPaths.openFile(function() {
        return fsUtil.unlink(path, function(err) {
          balUtilPaths.closeFile();
          return next(err);
        });
      });
      return this;
    },
    rmdir: function(path, next) {
      balUtilPaths.openFile(function() {
        return fsUtil.rmdir(path, function(err) {
          balUtilPaths.closeFile();
          return next(err);
        });
      });
      return this;
    },
    exists: function(path, next) {
      var exists;

      exists = fsUtil.exists || pathUtil.exists;
      balUtilPaths.openFile(function() {
        return exists(path, function(exists) {
          balUtilPaths.closeFile();
          return next(exists);
        });
      });
      return this;
    },
    existsSync: function(path) {
      var existsSync, result;

      existsSync = fsUtil.existsSync || pathUtil.existsSync;
      result = existsSync(path);
      return result;
    },
    isTextSync: function(filename, buffer) {
      var extension, isText, _i, _len;

      isText = null;
      if (filename) {
        filename = pathUtil.basename(filename).split('.');
        for (_i = 0, _len = filename.length; _i < _len; _i++) {
          extension = filename[_i];
          if (__indexOf.call(balUtilPaths.textExtensions, extension) >= 0) {
            isText = true;
            break;
          }
          if (__indexOf.call(balUtilPaths.binaryExtensions, extension) >= 0) {
            isText = false;
            break;
          }
        }
      }
      if (buffer && isText === null) {
        isText = balUtilPaths.getEncodingSync(buffer) === 'utf8';
      }
      return isText;
    },
    isText: function(filename, buffer, next) {
      var result;

      result = this.isTextSync(filename, buffer);
      if (result instanceof Error) {
        next(err);
      } else {
        next(null, result);
      }
      return this;
    },
    getEncodingSync: function(buffer, opts) {
      var binaryEncoding, charCode, chunkBegin, chunkEnd, chunkLength, contentChunkUTF8, encoding, i, textEncoding, _i, _ref6;

      textEncoding = 'utf8';
      binaryEncoding = 'binary';
      if (opts == null) {
        chunkLength = 24;
        encoding = balUtilPaths.getEncodingSync(buffer, {
          chunkLength: chunkLength,
          chunkBegin: chunkBegin
        });
        if (encoding === textEncoding) {
          chunkBegin = Math.max(0, Math.floor(buffer.length / 2) - chunkLength);
          encoding = balUtilPaths.getEncodingSync(buffer, {
            chunkLength: chunkLength,
            chunkBegin: chunkBegin
          });
          if (encoding === textEncoding) {
            chunkBegin = Math.max(0, buffer.length - chunkLength);
            encoding = balUtilPaths.getEncodingSync(buffer, {
              chunkLength: chunkLength,
              chunkBegin: chunkBegin
            });
          }
        }
      } else {
        chunkLength = opts.chunkLength, chunkBegin = opts.chunkBegin;
        if (chunkLength == null) {
          chunkLength = 24;
        }
        if (chunkBegin == null) {
          chunkBegin = 0;
        }
        chunkEnd = Math.min(buffer.length, chunkBegin + chunkLength);
        contentChunkUTF8 = buffer.toString(textEncoding, chunkBegin, chunkEnd);
        encoding = textEncoding;
        for (i = _i = 0, _ref6 = contentChunkUTF8.length; 0 <= _ref6 ? _i < _ref6 : _i > _ref6; i = 0 <= _ref6 ? ++_i : --_i) {
          charCode = contentChunkUTF8.charCodeAt(i);
          if (charCode === 65533 || charCode <= 8) {
            encoding = binaryEncoding;
            break;
          }
        }
      }
      return encoding;
    },
    getEncoding: function(buffer, opts, next) {
      var result;

      result = this.getEncodingSync(buffer, opts);
      if (result instanceof Error) {
        next(err);
      } else {
        next(null, result);
      }
      return this;
    },
    cp: function(src, dst, next) {
      balUtilPaths.readFile(src, 'binary', function(err, data) {
        if (err) {
          return next(err);
        }
        return balUtilPaths.writeFile(dst, data, 'binary', function(err) {
          return next(err);
        });
      });
      return this;
    },
    getParentPathSync: function(p) {
      var parentPath;

      parentPath = p.replace(/[\/\\][^\/\\]+$/, '');
      return parentPath;
    },
    ensurePath: function(path, next) {
      path = path.replace(/[\/\\]$/, '');
      balUtilPaths.exists(path, function(exists) {
        var parentPath;

        if (exists) {
          return next(null, true);
        }
        parentPath = balUtilPaths.getParentPathSync(path);
        return balUtilPaths.ensurePath(parentPath, function(err) {
          if (err) {
            return next(err, false);
          }
          return balUtilPaths.mkdir(path, '700', function(err) {
            return balUtilPaths.exists(path, function(exists) {
              if (!exists) {
                err = new Error("Failed to create the directory: " + path);
                return next(err, false);
              }
              return next(null, false);
            });
          });
        });
      });
      return this;
    },
    prefixPathSync: function(path, parentPath) {
      path = path.replace(/[\/\\]$/, '');
      if (/^([a-zA-Z]\:|\/)/.test(path) === false) {
        path = pathUtil.join(parentPath, path);
      }
      return path;
    },
    isDirectory: function(path, next) {
      if ((path != null ? path.isDirectory : void 0) != null) {
        return next(null, path.isDirectory(), path);
      } else {
        balUtilPaths.stat(path, function(err, stat) {
          if (err) {
            return next(err);
          }
          return next(null, stat.isDirectory(), stat);
        });
      }
      return this;
    },
    generateSlugSync: function(path) {
      var result;

      result = path.replace(/[^a-zA-Z0-9]/g, '-').replace(/^-/, '').replace(/-+/, '-');
      return result;
    },
    scanlist: function(path, next) {
      balUtilPaths.scandir({
        path: path,
        readFiles: true,
        ignoreHiddenFiles: true,
        next: function(err, list) {
          return next(err, list);
        }
      });
      return this;
    },
    scantree: function(path, next) {
      balUtilPaths.scandir({
        path: path,
        readFiles: true,
        ignoreHiddenFiles: true,
        next: function(err, list, tree) {
          return next(err, tree);
        }
      });
      return this;
    },
    testIgnorePatterns: function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.isIgnoredPath.apply(this, args);
    },
    isIgnoredPath: function(path, opts) {
      var basename, ignorePath, result, _i, _len, _ref10, _ref6, _ref7, _ref8, _ref9;

      if (opts == null) {
        opts = {};
      }
      result = false;
      basename = pathUtil.basename(path);
      if ((_ref6 = opts.ignorePaths) == null) {
        opts.ignorePaths = false;
      }
      if ((_ref7 = opts.ignoreHiddenFiles) == null) {
        opts.ignoreHiddenFiles = false;
      }
      if ((_ref8 = opts.ignoreCommonPatterns) == null) {
        opts.ignoreCommonPatterns = true;
      }
      if ((_ref9 = opts.ignoreCustomPatterns) == null) {
        opts.ignoreCustomPatterns = false;
      }
      if (opts.ignoreCommonPatterns === true) {
        opts.ignoreCommonPatterns = balUtilPaths.ignoreCommonPatterns;
      }
      if (opts.ignorePaths) {
        _ref10 = opts.ignorePaths;
        for (_i = 0, _len = _ref10.length; _i < _len; _i++) {
          ignorePath = _ref10[_i];
          if (path.indexOf(ignorePath) === 0) {
            result = true;
            break;
          }
        }
      }
      result = result || (opts.ignoreHiddenFiles && /^\./.test(basename)) || (opts.ignoreCommonPatterns && opts.ignoreCommonPatterns.test(basename)) || (opts.ignoreCustomPatterns && opts.ignoreCustomPatterns.test(basename)) || false;
      return result;
    },
    scandir: function() {
      var args, err, list, opts, tasks, tree, _ref10, _ref11, _ref12, _ref6, _ref7, _ref8, _ref9;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      list = {};
      tree = {};
      if (args.length === 1) {
        opts = args[0];
      } else if (args.length >= 4) {
        opts = {
          path: args[0],
          fileAction: args[1] || null,
          dirAction: args[2] || null,
          next: args[3] || null
        };
      } else {
        err = new Error('balUtilPaths.scandir: unsupported arguments');
        if (next) {
          return next(err);
        } else {
          throw err;
        }
      }
      if ((_ref6 = opts.recurse) == null) {
        opts.recurse = true;
      }
      if ((_ref7 = opts.readFiles) == null) {
        opts.readFiles = false;
      }
      if ((_ref8 = opts.ignorePaths) == null) {
        opts.ignorePaths = false;
      }
      if ((_ref9 = opts.ignoreHiddenFiles) == null) {
        opts.ignoreHiddenFiles = false;
      }
      if ((_ref10 = opts.ignoreCommonPatterns) == null) {
        opts.ignoreCommonPatterns = false;
      }
      if (opts.action != null) {
        if ((_ref11 = opts.fileAction) == null) {
          opts.fileAction = opts.action;
        }
        if ((_ref12 = opts.dirAction) == null) {
          opts.dirAction = opts.action;
        }
      }
      if (opts.parentPath && !opts.path) {
        opts.path = opts.parentPath;
      }
      if (!opts.path) {
        err = new Error('balUtilPaths.scandir: path is needed');
        if (next) {
          return next(err);
        } else {
          throw err;
        }
      }
      tasks = new balUtilFlow.Group(function(err) {
        return opts.next(err, list, tree);
      });
      balUtilPaths.readdir(opts.path, function(err, files) {
        if (tasks.exited) {
          return;
        } else if (err) {
          return tasks.exit(err);
        }
        tasks.total += files.length;
        if (!files.length) {
          return tasks.exit();
        } else {
          return files.forEach(function(file) {
            var fileFullPath, fileRelativePath, isIgnoredFile;

            fileFullPath = pathUtil.join(opts.path, file);
            fileRelativePath = opts.relativePath ? pathUtil.join(opts.relativePath, file) : file;
            isIgnoredFile = balUtilPaths.isIgnoredPath(fileFullPath, {
              ignorePaths: opts.ignorePaths,
              ignoreHiddenFiles: opts.ignoreHiddenFiles,
              ignoreCommonPatterns: opts.ignoreCommonPatterns,
              ignoreCustomPatterns: opts.ignoreCustomPatterns
            });
            if (isIgnoredFile) {
              return tasks.complete();
            }
            return balUtilPaths.isDirectory(fileFullPath, function(err, isDirectory, fileStat) {
              var complete;

              if (tasks.exited) {

              } else if (err) {
                return tasks.exit(err);
              } else if (isDirectory) {
                complete = function(err, skip, subtreeCallback) {
                  if (err) {
                    return tasks.exit(err);
                  }
                  if (tasks.exited) {
                    return tasks.exit();
                  }
                  if (skip !== true) {
                    list[fileRelativePath] = 'dir';
                    tree[file] = {};
                    if (!opts.recurse) {
                      return tasks.complete();
                    } else {
                      return balUtilPaths.scandir({
                        path: fileFullPath,
                        relativePath: fileRelativePath,
                        fileAction: opts.fileAction,
                        dirAction: opts.dirAction,
                        readFiles: opts.readFiles,
                        ignorePaths: opts.ignorePaths,
                        ignoreHiddenFiles: opts.ignoreHiddenFiles,
                        ignoreCommonPatterns: opts.ignoreCommonPatterns,
                        ignoreCustomPatterns: opts.ignoreCustomPatterns,
                        recurse: opts.recurse,
                        stat: opts.fileStat,
                        next: function(err, _list, _tree) {
                          var filePath, fileType;

                          tree[file] = _tree;
                          for (filePath in _list) {
                            if (!__hasProp.call(_list, filePath)) continue;
                            fileType = _list[filePath];
                            list[filePath] = fileType;
                          }
                          if (tasks.exited) {
                            return tasks.exit();
                          } else if (err) {
                            return tasks.exit(err);
                          } else if (subtreeCallback) {
                            return subtreeCallback(tasks.completer());
                          } else {
                            return tasks.complete();
                          }
                        }
                      });
                    }
                  } else {
                    return tasks.complete();
                  }
                };
                if (opts.dirAction) {
                  return opts.dirAction(fileFullPath, fileRelativePath, complete, fileStat);
                } else if (opts.dirAction === false) {
                  return complete(err, true);
                } else {
                  return complete(err, false);
                }
              } else {
                complete = function(err, skip) {
                  if (err) {
                    return tasks.exit(err);
                  }
                  if (tasks.exited) {
                    return tasks.exit();
                  }
                  if (skip) {
                    return tasks.complete();
                  } else {
                    if (opts.readFiles) {
                      return balUtilPaths.readFile(fileFullPath, function(err, data) {
                        var dataString;

                        if (err) {
                          return tasks.exit(err);
                        }
                        dataString = data.toString();
                        list[fileRelativePath] = dataString;
                        tree[file] = dataString;
                        return tasks.complete();
                      });
                    } else {
                      list[fileRelativePath] = 'file';
                      tree[file] = true;
                      return tasks.complete();
                    }
                  }
                };
                if (opts.fileAction) {
                  return opts.fileAction(fileFullPath, fileRelativePath, complete, fileStat);
                } else if (opts.fileAction === false) {
                  return complete(err, true);
                } else {
                  return complete(err, false);
                }
              }
            });
          });
        }
      });
      return this;
    },
    cpdir: function() {
      var args, err, next, opt, opts, outPath, scandirOpts, srcPath, _i, _len, _ref6;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      opts = {};
      if (args.length === 1) {
        opts = args[0];
      } else if (args.length >= 3) {
        srcPath = args[0], outPath = args[1], next = args[2];
        opts = {
          srcPath: srcPath,
          outPath: outPath,
          next: next
        };
      } else {
        err = new Error('balUtilPaths.cpdir: unknown arguments');
        if (next) {
          return next(err);
        } else {
          throw err;
        }
      }
      scandirOpts = {
        path: opts.srcPath,
        fileAction: function(fileSrcPath, fileRelativePath, next) {
          var fileOutPath;

          fileOutPath = pathUtil.join(opts.outPath, fileRelativePath);
          return balUtilPaths.ensurePath(pathUtil.dirname(fileOutPath), function(err) {
            if (err) {
              return next(err);
            }
            return balUtilPaths.cp(fileSrcPath, fileOutPath, function(err) {
              return next(err);
            });
          });
        },
        next: opts.next
      };
      _ref6 = ['ignorePaths', 'ignoreHiddenFiles', 'ignoreCommonPatterns', 'ignoreCustomPatterns'];
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        opt = _ref6[_i];
        scandirOpts[opt] = opts[opt];
      }
      balUtilPaths.scandir(scandirOpts);
      return this;
    },
    rpdir: function() {
      var args, err, next, opt, opts, outPath, scandirOpts, srcPath, _i, _len, _ref6;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      opts = {};
      if (args.length === 1) {
        opts = args[0];
      } else if (args.length >= 3) {
        srcPath = args[0], outPath = args[1], next = args[2];
        opts = {
          srcPath: srcPath,
          outPath: outPath,
          next: next
        };
      } else {
        err = new Error('balUtilPaths.cpdir: unknown arguments');
        if (next) {
          return next(err);
        } else {
          throw err;
        }
      }
      scandirOpts = {
        path: opts.srcPath,
        fileAction: function(fileSrcPath, fileRelativePath, next) {
          var fileOutPath;

          fileOutPath = pathUtil.join(opts.outPath, fileRelativePath);
          return balUtilPaths.ensurePath(pathUtil.dirname(fileOutPath), function(err) {
            if (err) {
              return next(err);
            }
            return balUtilPaths.isPathOlderThan(fileOutPath, fileSrcPath, function(err, older) {
              if (older === true || older === null) {
                return balUtilPaths.cp(fileSrcPath, fileOutPath, function(err) {
                  return next(err);
                });
              } else {
                return next();
              }
            });
          });
        },
        next: opts.next
      };
      _ref6 = ['ignorePaths', 'ignoreHiddenFiles', 'ignoreCommonPatterns', 'ignoreCustomPatterns'];
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        opt = _ref6[_i];
        scandirOpts[opt] = opts[opt];
      }
      balUtilPaths.scandir(scandirOpts);
      return this;
    },
    rmdirDeep: function(parentPath, next) {
      balUtilPaths.exists(parentPath, function(exists) {
        if (!exists) {
          return next();
        }
        return balUtilPaths.scandir(parentPath, function(fileFullPath, fileRelativePath, next) {
          return balUtilPaths.unlink(fileFullPath, function(err) {
            return next(err);
          });
        }, function(fileFullPath, fileRelativePath, next) {
          return next(null, false, function(next) {
            return balUtilPaths.rmdirDeep(fileFullPath, function(err) {
              return next(err);
            });
          });
        }, function(err, list, tree) {
          if (err) {
            return next(err, list, tree);
          }
          return balUtilPaths.rmdir(parentPath, function(err) {
            return next(err, list, tree);
          });
        });
      });
      return this;
    },
    writetree: function(dstPath, tree, next) {
      var tasks;

      tasks = new balUtilFlow.Group(function(err) {
        return next(err);
      });
      balUtilPaths.ensurePath(dstPath, function(err) {
        var fileFullPath, fileRelativePath, value;

        if (err) {
          return tasks.exit(err);
        }
        for (fileRelativePath in tree) {
          if (!__hasProp.call(tree, fileRelativePath)) continue;
          value = tree[fileRelativePath];
          ++tasks.total;
          fileFullPath = pathUtil.join(dstPath, fileRelativePath.replace(/^\/+/, ''));
          if (balUtilTypes.isObject(value)) {
            balUtilPaths.writetree(fileFullPath, value, tasks.completer());
          } else {
            balUtilPaths.writeFile(fileFullPath, value, function(err) {
              return tasks.complete(err);
            });
          }
        }
        if (tasks.total === 0) {
          tasks.exit();
        }
      });
      return this;
    },
    readPath: function(filePath, opts, next) {
      var data, err, http, req, requestOpts, tasks, zlib, _ref10, _ref11, _ref6, _ref7, _ref8, _ref9;

      _ref6 = balUtilFlow.extractOptsAndCallback(opts, next), opts = _ref6[0], next = _ref6[1];
      if (/^http/.test(filePath)) {
        data = '';
        tasks = new balUtilFlow.Group(function(err) {
          if (err) {
            return next(err);
          }
          return next(null, data);
        });
        requestOpts = require('url').parse(filePath);
        if ((_ref7 = requestOpts.path) == null) {
          requestOpts.path = requestOpts.pathname;
        }
        if ((_ref8 = requestOpts.method) == null) {
          requestOpts.method = 'GET';
        }
        if ((_ref9 = requestOpts.headers) == null) {
          requestOpts.headers = {};
        }
        http = requestOpts.protocol === 'https:' ? require('https') : require('http');
        zlib = null;
        try {
          zlib = require('zlib');
        } catch (_error) {
          err = _error;
        }
        req = http.request(requestOpts, function(res) {
          res.on('data', function(chunk) {
            return tasks.push(function(complete) {
              if (res.headers['content-encoding'] === 'gzip' && Buffer.isBuffer(chunk)) {
                if (zlib === null) {
                  err = new Error('Gzip encoding not supported on this environment');
                  return complete(err);
                }
                return zlib.unzip(chunk, function(err, chunk) {
                  if (err) {
                    return complete(err);
                  }
                  data += chunk;
                  return complete();
                });
              } else {
                data += chunk;
                return complete();
              }
            });
          });
          return res.on('end', function() {
            var locationHeader, _ref10;

            locationHeader = ((_ref10 = res.headers) != null ? _ref10.location : void 0) || null;
            if (locationHeader && locationHeader !== requestOpts.href) {
              return balUtilPaths.readPath(locationHeader, function(err, _data) {
                if (err) {
                  return tasks.exit(err);
                }
                data = _data;
                return tasks.exit();
              });
            } else {
              return tasks.run('serial');
            }
          });
        });
        if ((_ref10 = req.setTimeout) == null) {
          req.setTimeout = function(delay) {
            return setTimeout((function() {
              req.abort();
              return tasks.exit(new Error('Request timed out'));
            }), delay);
          };
        }
        req.setTimeout((_ref11 = opts.timeout) != null ? _ref11 : 10 * 1000);
        req.on('error', function(err) {
          return tasks.exit(err);
        }).on('timeout', function() {
          return req.abort();
        });
        req.end();
      } else {
        balUtilPaths.readFile(filePath, function(err, data) {
          if (err) {
            return next(err);
          }
          return next(null, data);
        });
      }
      return this;
    },
    empty: function(filePath, next) {
      balUtilPaths.exists(filePath, function(exists) {
        if (!exists) {
          return next(null, true);
        }
        return balUtilPaths.stat(filePath, function(err, stat) {
          if (err) {
            return next(err);
          }
          return next(null, stat.size === 0);
        });
      });
      return this;
    },
    isPathOlderThan: function(aPath, bInput, next) {
      var bMtime, bPath, mode;

      bMtime = null;
      if (balUtilTypes.isNumber(bInput)) {
        mode = 'time';
        bMtime = new Date(new Date() - bInput);
      } else {
        mode = 'path';
        bPath = bInput;
      }
      balUtilPaths.empty(aPath, function(err, empty) {
        if (empty || err) {
          return next(err, null);
        }
        return balUtilPaths.stat(aPath, function(err, aStat) {
          var compare;

          if (err) {
            return next(err);
          }
          compare = function() {
            var older;

            if (aStat.mtime < bMtime) {
              older = true;
            } else {
              older = false;
            }
            return next(null, older);
          };
          if (mode === 'path') {
            return balUtilPaths.empty(bPath, function(err, empty) {
              if (empty || err) {
                return next(err, null);
              }
              return balUtilPaths.stat(bPath, function(err, bStat) {
                if (err) {
                  return next(err);
                }
                bMtime = bStat.mtime;
                return compare();
              });
            });
          } else {
            return compare();
          }
        });
      });
      return this;
    }
  };

  module.exports = balUtilPaths;

}).call(this);
