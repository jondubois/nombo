var Cache = new (function () {
	var self = this;
	self.ENCODING_PLAIN = 'plain';
	self.ENCODING_SEPARATOR = '::';
	
	self._cache = {};
	self._excludeRegex = null;
	self._maxSize = 1000000000;
	self._maxEntrySize = 5000000;
	self._minCacheLifeMillis = 1000;
	
	self._head = null;
	self._tail = null;
	
	self.init = function (options) {
		self._excludeRegex = options.excludeRegex;
		self._maxSize = options.maxSize;
		self._maxEntrySize = options.maxEntrySize;
		self._minCacheLifeMillis = options.minCacheLifeMillis;
	};
	
	self._getFullKey = function (encoding, key) {
		return encoding + self.ENCODING_SEPARATOR + key;
	};
	
	self._floatCacheEntry = function (entry) {
		if (!self._head) {
			self._head = entry;
			self._tail = entry;
			entry.next = null;
		} else {
			if (entry.next) {
				entry.next.prev = entry.prev;
			} else if (entry.prev) {
				self._tail = entry.prev;
			}
			if (entry.prev) {
				entry.prev.next = entry.next;
			}
			self._head.prev = entry;
			entry.next = self._head;
			self._head = entry;
		}
		entry.prev = null;
	};
	
	self.set = function (encoding, key, data) {
		if (!(data instanceof Buffer || typeof data == 'string')) {
			return false;
		}
		var size = data.length;
		if (size > self._maxEntrySize || (self._excludeRegex && self._excludeRegex.test(key))) {
			return false;
		}
		
		var fullKey = self._getFullKey(encoding, key);
		if (self._cache.hasOwnProperty(fullKey)) {
			var lastCacheTime = self._cache[fullKey].time;
			var now = Date.now();
			if (now - lastCacheTime < self._minCacheLifeMillis) {
				return false;
			}
			self._cache[fullKey].data = data;
			self._cache[fullKey].time = now;
		} else {
			var entry = {
				key: fullKey
			};
			self._floatCacheEntry(entry);
			self._cache[fullKey] = {data: data, headers: {}, time: Date.now(), entry: entry};
		}
		
		return true;
	};
	
	self.get = function (encoding, key) {
		var fullKey = self._getFullKey(encoding, key);
		if (self._cache.hasOwnProperty(fullKey)) {
			self._floatCacheEntry(self._cache[fullKey].entry);
			return self._cache[fullKey].data;
		}
		return null;
	};
	
	self.getModifiedTime = function (encoding, key) {
		var fullKey = self._getFullKey(encoding, key);
		if (self._cache.hasOwnProperty(fullKey)) {
			return self._cache[fullKey].time;
		} else {
			return -1;
		}
	};
	
	self.has = function (encoding, key) {
		var fullKey = self._getFullKey(encoding, key);
		return self._cache.hasOwnProperty(fullKey) && self._cache[fullKey].hasOwnProperty('data');
	};
	
	self.clear = function (encoding, key) {
		var fullKey = self._getFullKey(encoding, key);
		delete self._cache[fullKey];
	};
	
	self.setHeader = function (encoding, objectKey, headerKey, headerValue) {
		var fullObjectKey = self._getFullKey(encoding, objectKey);
		
		if (!self._cache.hasOwnProperty(fullObjectKey)) {
			self._cache[fullObjectKey] = {headers: {}};
		}
		
		self._cache[fullObjectKey].headers[headerKey] = headerValue;
	};
	
	self.getHeader = function (encoding, objectKey, headerKey) {
		var fullObjectKey = self._getFullKey(encoding, objectKey);
		
		if (self._cache.hasOwnProperty(fullObjectKey)) {
			if (self._cache[fullObjectKey].headers.hasOwnProperty(headerKey)) {
				return self._cache[fullObjectKey].headers[headerKey];
			} else {
				return null;
			}
		}
		
		fullObjectKey = self._getFullKey(self.ENCODING_PLAIN, objectKey);
		
		if (self._cache.hasOwnProperty(fullObjectKey)) {
			if (self._cache[fullObjectKey].headers.hasOwnProperty(headerKey)) {
				return self._cache[fullObjectKey].headers[headerKey];
			}
		}
		
		return null;
	};
	
	self.setHeaders = function (encoding, objectKey, headerMap) {
		var i;
		for (i in headerMap) {
			self.setHeader(encoding, objectKey, i, headerMap[i]);
		}
	};
	
	self.getHeaders = function (encoding, objectKey) {
		var fullObjectKey = self._getFullKey(encoding, objectKey);
		if (self._cache.hasOwnProperty(fullObjectKey) && self._cache[fullObjectKey].headers) {
			return self._cache[fullObjectKey].headers;
		}
		return {};
	};
	
	self.clearHeader = function (encoding, objectKey, headerKey) {
		var fullObjectKey = self._getFullKey(encoding, objectKey);
		
		if (self._cache.hasOwnProperty(fullObjectKey) && self._cache[fullObjectKey].headers) {
			if (self._cache[fullObjectKey].headers.hasOwnProperty(headerKey)) {
				delete self._cache[fullObjectKey].headers[headerKey];
			}
		}
	};
	
	self.clearHeaders = function (encoding, objectKey) {
		var fullObjectKey = self._getFullKey(encoding, objectKey);
		
		if (self._cache.hasOwnProperty(fullObjectKey) && self._cache[fullObjectKey].headers) {
			self._cache[fullObjectKey].headers = {};
		}
	};
	
	self.clearMatches = function (regex) {
		var i;
		for (i in self._cache) {
			if (regex.test(i)) {
				delete self._cache[i];
			}
		}
	};
})();

module.exports = Cache;