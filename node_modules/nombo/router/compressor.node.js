var fs = require('fs'),
	path = require('path'),
	zlib = require('zlib'),
	cache = require('nombo/cache');

var Compressor = new (function() {
	var self = this;
	
	self.run = function(req, res, next) {
		if(req.rout.buffer === null) {
			var buffers = [];
			var lastStream = req.rout.getLastStream();
			
			var compressorStream;
			if(req.rout.encoding == 'gzip') {
				compressorStream = zlib.createGzip();
				lastStream.pipe(compressorStream);
			} else if(req.rout.encoding == 'deflate') {
				compressorStream = deflate.createGzip();
				lastStream.pipe(compressorStream);
			} else {
				compressorStream = lastStream;
			}
			
			compressorStream.on('data', function(data) {
				buffers.push(data);
			});
			
			compressorStream.on('error', function(err) {
				compressorStream.destroy();
			});
			
			compressorStream.on('end', function() {
				var data, buf;
				var resBuffer = Buffer.concat(buffers);
				
				cache.set(req.rout.encoding, req.url, resBuffer);
			});
			
			lastStream.on('error', function(err) {
				compressorStream.emit('error', err);
			});
			
			req.rout.appendStream(compressorStream);
			
			next();
		} else {
			if(typeof req.rout.buffer == 'string') {
				req.rout.buffer = new Buffer(req.rout.buffer, 'utf8');
			}
		
			var compressed = function(err, result) {
				if(err) {
					res.writeHead(500);
					res.end('Failed to compress ' + req.url);
				} else {
					req.rout.buffer = result;
					cache.set(req.rout.encoding, req.url, req.rout.buffer);
					next();
				}
			}
			
			if(req.rout.encoding == 'gzip') {
				zlib.gzip(req.rout.buffer, compressed);
			} else if(req.rout.encoding == 'deflate') {
				zlib.deflate(req.rout.buffer, compressed);
			} else {
				compressed(null, req.rout.buffer);
			}
		}
	}
})();

module.exports = Compressor;
