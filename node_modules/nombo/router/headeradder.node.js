var mime = require('mime'),
	cache = require('nombo/cache');

var HeaderAdder = new (function() {
	var self = this;
	
	self._options = {
		clientCacheLife: 2592000,
		clientCacheType: 'private'
	};
	
	var isEmpty = function (object) {
		for (var i in object) {
			return false;
		}
		return true;
	};
	
	self.getOptions = function() {
		return self._options;
	};
	
	self.init = function (options) {
		var i;
		for (i in options) {
			self._options[i] = options[i];
		}
	};
	
	self.run = function (req, res, next) {
		var mimeType;
		
		if (req.rout.mimeType) {
			mimeType = req.rout.mimeType;
		} else {
			mimeType = mime.lookup(req.rout.filePath);
		}
		
		if (req.rout.encoding) {
			encoding = req.rout.encoding;
			res.setHeader('Content-Encoding', encoding);
		} else {
			encoding = cache.ENCODING_PLAIN;
		}
		
		res.setHeader('Content-Type', mimeType);
		res.setHeader('Server', 'Nombo (Node.js)');
		
		if (req.rout.skipCache) {
			res.setHeader('Cache-Control', 'no-cache, must-revalidate');
			res.setHeader('Pragma', 'no-cache');
			next();
		} else if (!isEmpty(req.params)) {
			var now = new Date();
			var exp = new Date(now.getTime() + self._options.clientCacheLife * 1000).toUTCString();
			res.setHeader('Cache-Control', self._options.clientCacheType);
			res.setHeader('Pragma', self._options.clientCacheType);
			res.setHeader('Expires', exp);
			res.setHeader('ETag', cache.getModifiedTime(encoding, req.url));
			next();
		} else {
			res.setHeader('Cache-Control', 'no-cache, must-revalidate');
			res.setHeader('Pragma', 'no-cache');
			res.setHeader('ETag', cache.getModifiedTime(encoding, req.url));
			next();
		}
	};
})();

module.exports = HeaderAdder;