var engine = require('engine.io');
var EventEmitter = require('events').EventEmitter;
var Socket = engine.Socket;
var json = require('./json').JSON;

module.exports = ClusterSocket;

function ClusterSocket(id, server, transport, namespace) {
	this._internalEvents = {
		'open': 1,
		'packet': 1,
		'heartbeat': 1,
		'data': 1,
		'message': 1,
		'upgrade': 1,
		'close': 1,
		'packetCreate': 1,
		'flush': 1,
		'drain': 1
	};
	
	Socket.call(this, id, server, transport);
	
	var self = this;
	this.namespace = namespace || '__';
	
	this._cid = 1;
	this._callbackMap = {};
	
	Socket.prototype.on.call(this, 'message', function (message) {
		var e = json.parse(message);
		
		if(e.event) {
			var eventName = e.ns + '.' + e.event;
			var responder;
			if (e.cid) {
				responder = function (data) {
					var responseObject = {
						response: e.cid,
					};
					if (data) {
						responseObject.data = data;
					}
					Socket.prototype.send.call(self, json.stringify(responseObject));
				};
			} else {
				responder = function () {};
			}
			EventEmitter.prototype.emit.call(self, eventName, e.data, responder);
		} else if (e.response != null) {
			var ret = self._callbackMap[e.response];
			if (ret) {
				clearTimeout(ret.timeout);
				ret.callback(null, e.data);
			}
		}
	});
};

ClusterSocket.prototype = Object.create(Socket.prototype);

ClusterSocket.prototype.ns = function (namespace) {
	return new ClusterSocket(this.id, this.server, this.transport, namespace);
};

ClusterSocket.prototype._nextCallId = function () {
	return this.namespace + '-' + this._cid++;
};

ClusterSocket.prototype.emit = function (event, data, callback) {
	if (this._internalEvents[event] == null) {
		var eventObject = {
			ns: this.namespace,
			event: event
		};
		if (data !== undefined) {
			eventObject.data = data;
		}
		if (callback) {
			var self = this;
			var cid = this._nextCallId();
			eventObject.cid = cid;
			
			var timeout = setTimeout(function () {
				delete self._callbackMap[cid];
				callback('Event response timed out', eventObject);
			}, this.server.pingTimeout);
			
			this._callbackMap[cid] = {callback: callback, timeout: timeout};
		}
		Socket.prototype.send.call(this, json.stringify(eventObject));
	} else {
		EventEmitter.prototype.emit.apply(this, arguments);
	}
};

ClusterSocket.prototype.on = function (event, listener) {
	if (this._internalEvents[event] == null) {
		var eventName = this.namespace + '.' + event;
		EventEmitter.prototype.on.call(this, eventName, listener);
	} else {
		EventEmitter.prototype.on.apply(this, arguments);
	}
};

ClusterSocket.prototype.removeListener = function (event, listener) {
	if (this._internalEvents[event] == null) {
		var eventName = this.namespace + '.' + event;
		EventEmitter.prototype.removeListener.call(this, eventName, listener);
	} else {
		EventEmitter.prototype.removeListener.apply(this, arguments);
	}
};

ClusterSocket.prototype.removeAllListeners = function (event) {
	if (event) {
		event = this.namespace + '.' + event;
	}
	EventEmitter.prototype.removeAllListeners.call(this, event);
};

ClusterSocket.prototype.listeners = function (event) {
	event = this.namespace + '.' + event;
	EventEmitter.prototype.listeners.call(this, event);
};