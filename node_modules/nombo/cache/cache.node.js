var Cache = new (function() {
	var self = this;
	self.ENCODING_PLAIN = 'plain';
	self.ENCODING_SEPARATOR = '::';
	
	self._cache = {};
	
	self.set = function(encoding, key, data) {
		var fullKey = encoding + self.ENCODING_SEPARATOR + key;
		if(self._cache.hasOwnProperty(fullKey)) {
			self._cache[fullKey].data = data;
		} else {
			self._cache[fullKey] = {data: data, headers: {}};
		}
	}
	
	self.get = function(encoding, key) {
		var fullKey = encoding + self.ENCODING_SEPARATOR + key;
		if(self._cache.hasOwnProperty(fullKey)) {
			return self._cache[fullKey].data;
		}
		return null;
	}
	
	self.has = function(encoding, key) {
		var fullKey = encoding + self.ENCODING_SEPARATOR + key;
		return self._cache.hasOwnProperty(fullKey) && self._cache[fullKey].hasOwnProperty('data');
	}
	
	self.clear = function(encoding, key) {
		var fullKey = encoding + self.ENCODING_SEPARATOR + key;
		delete self._cache[fullKey];
	}
	
	self.setHeader = function(encoding, objectKey, headerKey, headerValue) {
		var fullObjectKey = encoding + self.ENCODING_SEPARATOR + objectKey;
		
		if(!self._cache.hasOwnProperty(fullObjectKey)) {
			self._cache[fullObjectKey] = {headers: {}};
		}
		
		self._cache[fullObjectKey].headers[headerKey] = headerValue;
	}
	
	self.getHeader = function(encoding, objectKey, headerKey) {
		var fullObjectKey = encoding + self.ENCODING_SEPARATOR + objectKey;
		
		if(self._cache.hasOwnProperty(fullObjectKey)) {
			if(self._cache[fullObjectKey].headers.hasOwnProperty(headerKey)) {
				return self._cache[fullObjectKey].headers[headerKey];
			} else {
				return null;
			}
		}
		
		fullObjectKey = self.ENCODING_PLAIN + self.ENCODING_SEPARATOR + objectKey;
		
		if(self._cache.hasOwnProperty(fullObjectKey)) {
			if(self._cache[fullObjectKey].headers.hasOwnProperty(headerKey)) {
				return self._cache[fullObjectKey].headers[headerKey];
			}
		}
		
		return null;
	}
	
	self.setHeaders = function(encoding, objectKey, headerMap) {
		var i;
		for(i in headerMap) {
			self.setHeader(encoding, objectKey, i, headerMap[i]);
		}
	}
	
	self.getHeaders = function(encoding, objectKey) {
		var fullObjectKey = encoding + self.ENCODING_SEPARATOR + objectKey;
		if(self._cache.hasOwnProperty(fullObjectKey) && self._cache[fullObjectKey].headers) {
			return self._cache[fullObjectKey].headers;
		}
		return {};
	}
	
	self.clearHeader = function(encoding, objectKey, headerKey) {
		var fullObjectKey = encoding + self.ENCODING_SEPARATOR + objectKey;
		
		if(self._cache.hasOwnProperty(fullObjectKey) && self._cache[fullObjectKey].headers) {
			if(self._cache[fullObjectKey].headers.hasOwnProperty(headerKey)) {
				delete self._cache[fullObjectKey].headers[headerKey];
			}
		}
	}
	
	self.clearHeaders = function(encoding, objectKey) {
		var fullObjectKey = encoding + self.ENCODING_SEPARATOR + objectKey;
		
		if(self._cache.hasOwnProperty(fullObjectKey) && self._cache[fullObjectKey].headers) {
			self._cache[fullObjectKey].headers = {};
		}
	}
	
	self.clearMatches = function(regex) {
		var i;
		for(i in self._cache) {
			if(regex.test(i)) {
				delete self._cache[i];
			}
		}
	}
})();

module.exports = Cache;