var path = require('path'),
	fs = require('fs'),
	async = require('async'),
	io = require('socket.io-client'),
	wrench = require('wrench'),
	EventEmitter = require('events').EventEmitter,
	chokidar = require('chokidar');

var Gateway = function() {
	var self = this;
	self._siDir = null;
	self._dataClient = null;
	self._serverInterfaces = {};
	self._privateExtension = [];
	self._privateExtensionRegex = /$a/;
	self._allowedMap = {'*': true};
	self._releaseMode = false;
	
	var publicExt = /(.*)[.]js$/;
	
	self.getSiName = function(siPath) {
		return path.relative(self._siDir, siPath).replace(/\\/g, '/').replace(self._privateExtensionRegex, '').replace(/[.]js$/, '');
	}
	
	self.init = function(serverInterfaceDir, dataClient, customSIMExtension) {
		self._siDir = path.normalize(serverInterfaceDir);
		self._dataClient = dataClient;
		
		if(customSIMExtension) {
			self._privateExtension = customSIMExtension;
			self._privateExtensionRegex = new RegExp('[.](' + self._privateExtension.replace(/[.]/g, '[.]') + ')$');
		}
		
		var files = wrench.readdirSyncRecursive(self._siDir);
		var serverInterfaceFiles = fs.readdirSync(self._siDir);
		var i, file, siName, match;
		var privateExt = new RegExp('(.*)(' + self._privateExtensionRegex.source + ')');
		var backslashes = /\\/g;
		var watcher = chokidar.watch(self._siDir);
		var siPath;
		for(i in files) {
			file = files[i];
			match = file.match(privateExt);
			if(match) {
				siName = match[1].replace(backslashes, '/');
				if(!self._serverInterfaces.hasOwnProperty(siName)) {
					siPath = self._siDir + file;
					self._serverInterfaces[siName] = require(siPath);
				}
			} else {
				match = file.match(publicExt);
				if(match) {
					siName = match[1].replace(backslashes, '/');
					if(!self._serverInterfaces.hasOwnProperty(siName)) {
						siPath = self._siDir + file;
						self._serverInterfaces[siName] = require(siPath);
					}
				}
			}
		}
	}
	
	self.setReleaseMode = function(bool) {
		self._releaseMode = bool;
	}
	
	self.exec = function(ioReq, ioRes) {
		var serverInterface = ioReq.sim;
		var method = ioReq.method;
		self._serverInterfaces[serverInterface][method](ioReq, ioRes);
	}
	
	self._getSessionEventKey = function(sessionID, key) {
		if(key) {
			return '__sessionevent.' + self._dataClient.escape(sessionID) + '.' + self._dataClient.escape(key);
		} else {
			return '__sessionevent.' + self._dataClient.escape(sessionID);
		}
	}
	
	self.watch = function(ioReq, ioRes) {
		var ns = ioReq.ns;
		var event = ioReq.event;
		var id = ioReq.session.id;
		
		var eventKey = ns + '.' + event;
		var sessionEventString = self._getSessionEventKey(id, eventKey);
		
		var handler = function(value) {
			ioReq.session.ns(ns).emit(event, value);
		}
		
		self._dataClient.watchExclusive(sessionEventString, handler, function(err, alreadyWatching) {
			if(err) {
				ioRes.error(err);
			} else {
				ioRes.end(alreadyWatching);
			}
		});
	}
	
	self.unwatch = function(ioReq, ioRes) {
		var socket = ioReq.socket;
		var id = ioReq.session.id;
		
		var ns = ioReq.ns;
		var event = ioReq.event;
		var eventKey;
		
		if(event) {
			eventKey = ns + '.' + event;
		} else {
			eventKey = ns;
		}
		
		var sessionEventString = self._getSessionEventKey(id, eventKey);
		
		self._dataClient.unwatch(sessionEventString, null, function(err) {
			if(err) {
				ioRes.error(err);
			} else {
				ioRes.end();
			}
		});
	}
	
	self.unwatchAll = function(session, ackCallback) {
		var sessionEventString = self._getSessionEventKey(session.id);
		self._dataClient.unwatch(sessionEventString, null, ackCallback);
	}
}

Gateway.prototype.__proto__ = EventEmitter.prototype;

module.exports = new Gateway();
