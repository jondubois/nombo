var http = require('http');
var httpProxy = require('http-proxy');
var url = require('url');
var crypto = require('crypto');
var ComSocket = require('ncom').ComSocket;
var SimpleSocketProxy = require('simplesocketproxy').SimpleSocketProxy;
var domain = require('domain');

var LoadBalancer = function (options) {
	var self = this;
	
	this._errorDomain = domain.create();
	this._errorDomain.on('error', function (err) {
		self.emit('error', err);
	});

	this.protocol = options.protocol || 'http';
	this.protocolOptions = options.protocolOptions;
	this.sourcePort = options.sourcePort;
	
	this.setWorkers(options.workers);
	
	this.dataKey = options.dataKey;
	this.checkWorkersInterval = 5000;

	this._destRegex = /^([^_]*)_([^_]*)_/;
	this._sidRegex = /([^A-Za-z0-9]|^)s?sid=([^;]*)/;

	var proxyHTTP = this._errorDomain.bind(function (req, res, proxy) {
		var dest = self._parseDest(req);
		if (dest) {
			if (self.destPorts[dest.port] == null) {
				dest.port = self._randomPort();
			}
		} else {
			dest = {
				host: 'localhost',
				port: self.leastBusyPort
			};
		}
		
		proxy.proxyRequest(req, res, dest);
	});
	
	var socketProxy = new SimpleSocketProxy();
	this._errorDomain.add(socketProxy);

	var proxyWebSocket = this._errorDomain.bind(function (req, socket, head) {
		var dest = self._parseDest(req);
		if (dest) {
			if (self.destPorts[dest.port] == null) {
				dest.port = self._randomPort();
			}
		} else {
			dest = {
				host: 'localhost',
				port: self.leastBusyPort,
			};
		}
		
		socketProxy.proxy(req, socket, dest);
	});
	
	this.workerStatuses = {};
	this.leastBusyPort = this._randomPort();
	
	this._server = httpProxy.createServer(proxyHTTP);
	this._server.on('upgrade', proxyWebSocket);
	
	this._errorDomain.add(this._server);
	
	this._server.listen(this.sourcePort);
};

LoadBalancer.prototype.setWorkers = function (workers) {
	this.destPorts = {};
	var i;
	
	for (i in workers) {
		this.destPorts[workers[i].port] = 1;
	}
	for (i in this.workers) {
		if (this.destPorts[this.workers[i].port] == null && this.workers[i].socket) {
			this.workers[i].socket.end();
		}
	}
	this.workers = workers;
	
	this._watchWorkerStatuses();
};

LoadBalancer.prototype._watchWorkerStatuses = function () {
	var self = this;
	var socket, port;
	
	for (i in this.workers) {
		port = this.workers[i].port;
		socket = new ComSocket();
		socket.connect(this.workers[i].statusPort, 'localhost');
		
		(function (port) {
			socket.on('message', function (message) {
				var decipher = crypto.createDecipher('aes192', self.dataKey);
				message = decipher.update(message, 'base64', 'utf8');
				message += decipher.final('utf8');
				var data = JSON.parse(message);
				self.workerStatuses[port] = data;
			});
			
			socket.on('close', function () {
				self.workerStatuses[port] = null;
			});
		})(port);
		
		this.workers[i].socket = socket;
	}
	
	setInterval(this._updateStatus.bind(this), this.checkWorkersInterval);
};

LoadBalancer.prototype._randomPort = function () {
	var rand = Math.floor(Math.random() * this.workers.length);
	return this.workers[rand].port;
};

LoadBalancer.prototype._updateStatus = function () {
	var minBusiness = Infinity;
	var leastBusyPort;
	var httpRPM, ioRPM, clientCount, business;
	
	for (var i in this.workerStatuses) {
		if (this.workerStatuses[i]) {
			clientCount = this.workerStatuses[i].clientCount;
			httpRPM = this.workerStatuses[i].httpRPM;
			ioRPM = this.workerStatuses[i].ioRPM;
		} else {
			clientCount = Infinity;
			httpRPM = Infinity;
			ioRPM = Infinity;
		}
		business = httpRPM + ioRPM + clientCount;
		
		if (business < minBusiness) {
			minBusiness = business;
			leastBusyPort = parseInt(i);
		}
	}
	if (minBusiness == Infinity) {
		leastBusyPort = this._randomPort();
	}
	
	this.leastBusyPort = leastBusyPort;
};

LoadBalancer.prototype._parseDest = function (req) {
	var urlData = url.parse(req.url);
	var query = urlData.query || '';
	var cookie = '';
	
	if (req.headers && req.headers.cookie) {
		cookie = req.headers.cookie;
	}
	
	if (!query && !cookie) {
		return null;
	}
	
	var matches = query.match(this._sidRegex) || cookie.match(this._sidRegex);
	
	if (!matches) {
		return null;
	}
	
	var routString = matches[2];
	var result = routString.match(this._destRegex);
	
	if (!result) {
		return null;
	}
	
	var dest = {
		host: 'localhost',
		port: parseInt(result[2]) || this.leastBusyPort
	};
	
	return dest;
};

module.exports = LoadBalancer;